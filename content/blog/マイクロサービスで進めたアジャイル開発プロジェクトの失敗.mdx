---
date: 2021-04-16T22:44:38.000+00:00
title: マイクロサービスで進めたアジャイル開発プロジェクトの失敗
thumbnail: 'https://res.cloudinary.com/dso4npatn/image/upload/v1646834505/media/blog/thumbnail/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%92%E3%82%99%E3%82%B9%E3%81%A6%E3%82%99%E9%80%B2%E3%82%81%E3%81%9F%E3%83%95%E3%82%9A%E3%83%AD%E3%82%B7%E3%82%99%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%A4%B1%E6%95%97_emteji.png'
tag:
  - コラム
---

タイトル通り、世の中のプロジェクトが成功事例ばかりではないという現場の真実をお伝えする意味も込めてエントリーします。
ただ、もちろん詳細に書いてしまうとプロジェクトに携わったメンバーや企業に迷惑がかかってしまうので、プロジェクトが特定されないよう抽象的に書きます。
読んでくださっている皆様にも、このような事例を参考にしてもらえたら幸いです。

## どんな開発をしていたの？

ある業種の設計サービスを開発していました。  
大まかな説明で言うと、「**必要項目を入力して、業務計算や業務チェック判定をしながら、最終的には必要な手続きまで行える見積もりサービスの Web アプリ**」を作っていたのです。
私は開発フェーズからアプリエンジニアとして、フロントエンドとバックエンドもできるメンバーとして参加しました。比較的メンバーの中では React が得意だったこともあり、プロジェクト開始１ヶ月後にはフロントエンドのリード的ポジションを担っていました。

### 開発体制

スクラム開発で、体制としては設計チーム、開発チーム、テストチームの３つに分かれていて、設計チームにプロダクトオーナーや開発チームにアジャイルコーチなどが在籍していました。設計チームから機能に応じたチケットが発行され、それを開発者で作業分担/振り分け、開発完了後テストチームへテスト依頼するというような流れで進んでいました。チーム合わせて 30 人近くのメンバーが在籍していたように思います。  
開発メンバーは当初５人でしたが、途中から 10 人以上の開発メンバーとなったため、実装する画面機能に応じて２チームへ分割されて効率化が図られました。(開発体制の変更はお偉い方々の意向で結構多く発生し、なかなかに開発サイクルが安定稼働せず辛い部分もありました 😢)
開発サイクルとしては、２週間単位のスプリント計画で、前半と少し後半に入ったくらいで開発すべき機能を実装して、後半に「開発者側からプロダクトオーナーへ実装機能のデモを実施」 → 「スプリント終了後に反省会」 → 「次のスプリント計画を立てる」というような流れでした。アジャイルなので、デモ後に仕様の細かな変更やデザイン調整も入ってくるようなイメージです。

### アーキテクチャ

プロジェクトのアーキテクチャは比較的モダンな構成で挑んでいました。サーバーサイドは SpringBoot で Swagger を使った OpenAPI、フロントエンドは React で SPA、さらに「各業務に応じてサービスを分割しておきたい」というニーズから３層構造のマイクローサービスを採用していました。この３層構造のマイクロサービスでは、ExperienceAPI、ProcessAPI、SystemAPI の３つのことを指します。
各３つの API の役割は以下の通りです。

- ExperienceAPI...ユーザーがアクセスするインターフェースを提供します。このプロジェクトでは、ビルドされた React アプリケーションの提供と Express で立てられたプロキシが対象になりました。プロキシは API コール時やユーザー操作のロギングが内部実装されています
- ProcessAPI...外部 API や SystemAPI など複数の API へアクセスして、アプリに必要な JSON データを適切に変換/整形して ExperienceAPI へ返却します。各業務(Domain)ごとに作成されます。
- SystemAPI...1 つの DB に対して１つの SystemAPI が対応し、DB 操作(CRUD)のエンドポイントが用意されており、基本的に返却されるデータは DB エンティティのまま JSON が返却されます。

これらの３層構造を採用した結果、API の数は ExperienceAPI が 1 個、ProcessAPI が 5 個、SystemAPI が 4 個となっていました。これはつまり、GitHub のプロジェクト上にリポジトリの数が合計 10 個存在していたということです。

バックエンドで RESTfulAPI を実現する上で共通する機能(バリデーションや HTTP エラーハンドリングなど)は Artifactory に maven リポジトリを登録して、それをパッケージ追加することで各バックエンド API の共通化を図っていました。

おおよその API 間の関係を図に示すと以下のようになります。マイクロサービスあるあるですがサービスメッシュが複雑になりました。外部 API へのアクセスについては、REST ではなく SOAP 通信やクライアントドライバーを必要とする社内レガシーサービスも存在しており、1 つのエンドポイントを呼び出すだけで複数個の API を跨ぐケースもありました。

![](https://res.cloudinary.com/dso4npatn/image/upload/v1647150481/media/blog/insert/-2021-04-19-22.22.40_ikhtdc.png)

### CI/CD

当初、ローカルでの開発は Docker を起動して各 API を立ち上げていましたが、メモリの大量消費や開発 PC の制約が重なり、Docker を使わずに複数のプロセスを立ち上げる方式に変わっていきました。バックエンドの DB は h2 のインメモリ DB を使ってリソースを節約したり、開発 PC のメモリが 8GB だったり、あまり贅沢な開発とは言えなかったと思います。
途中からはきちんとした CI/CD が整備され、ローカルで実施していたデモも開発環境で行えるようになりました。PR 提出時は Hooks を使ったユニットテスト実行やコード分析が行われたり、Openshift に開発環境用、テスト環境用のプロジェクトが構築されて各リポジトリの develop ブランチマージ後にデプロイされるように自動化されていきました。
Openshift は Kubernetes を包括したクラウドネイティブなサービスで、コンソールからログやビルド/デプロイの設定(yml 編集)が簡単に実行できたりマイクロサービスを展開するのに便利なサービスでした。とはいえ、デバッグ時やビルド/デプロイ用のパイプライン構築にはなかなか時間を取られていたように思います...。

![](https://res.cloudinary.com/dso4npatn/image/upload/v1647150481/media/blog/insert/-2021-04-19-22.22.45_fdyhj6.png)

### 開発中止の知らせが届くまで

開発が進むにつれ、多くのチーム的課題や技術的課題が上がりました。ただ、チーム的課題については割とコミュニケーションで解決できることも多かったので、「次のスプリントでは解消されました！」みたいなことがほとんだったと思います。それでも人数が増えて様々なトピックがチャットで飛び交うことも多かったので、コンセンサスをとるのにミーティングを繰り返して解決方向を探っていたので、チーム自体の意思決定スピードは遅くなっていったと思います。  
ただそれよりも開発側として多く頭を悩ましたのは技術的課題の方でした。開発中にすぐには解決できない問題やいずれ解決しないといけない問題は TechnicalDebt(技術的負債)として管理されていました。これらの課題は、機能単位の問題というよりは全体的なアーキテクチャの問題を取り扱うことが多かったので、課題解決には慎重を要するので時間を取られたように思います。深掘りしませんが、ざっと思い出せる話題に上がったものを列挙するとこんな感じです。

- DB エンティティの部分更新(冗長な DTO の削除)
- レスポンス型の設計方針
- 一部の外部サービスとの req/res 調整とセットアップ
- バリデーションの適用
- トランザクション
- 複数 API の呼び出し管理
- Reducer の設計方針
- React のユニットテストの書き方
- ロギング
- コードフォーマットの設定

以上の話題は開発者同士で解決できたものもあれば、最後までうやむやになってしまっていたものもありました。開発前にある程度予期しておかないといけないものもありましたし、そこは開発チーム全体の反省点でした。

それら以外には、デザイン調整が遅かったり、仕様の複雑化、暫定対応の多発で開発を続けるのが難しいような状況がスプリントを進める上で続いていました。
最終的には開発予算の調整が合わないのと開発優先度が高いプロジェクトの発生により、このプロジェクトで開発されていたアプリはリリースを迎えることなく、一時中断という判断になりました。

<br />

## しくじりポイント

今回のプロジェクトで開発サイクルを回す上で、開発者の負荷を上げたポイントをしくじりポイントとしてまとめておきます。

### ・新規サービス開発に、複数 API を起動させて開発するのは混乱を招く

このプロジェクトでは、先ほども話した通り３層構造を採用しました。そのため、開発中に API 連携の部分で ExperienceAPI - ProcessAPI 間、ProcessAPI - SystemAPI 間でエラーが多発しました。他にも API 側の機能が未完成だったり、こまめに修正も入っていたのでモックサーバーで追随するのも大変でした。以下よく開発者が遭遇した事例です。

##### エラー例１：「あれ？動かなくなっている」 〜リクエスト/レスポンスの IF 変更〜

1. Dev 環境の画面上の API 呼び出しにて「サーバー接続エラー」
2. 開発者で原因解析
3. 原因は、A:「**リクエストが失敗(400:BadRequest)**」or B:「**API 接続エラー(500: InternalServerError)**」
4. A の場合は ProcessAPI が変更していた部分を、ExperienceAPI がキャッチアップできていなかった。
5. B の場合は SystemAPI が変更していた部分を、ProcessAPI がキャッチアップできていなかった。
6. 原因に応じて修正内容を、Dev 環境へデプロイして対応完了。

##### エラー例２： 「モックでは動いていたんですけどね...」 〜モックサーバーのジレンマ〜

1. 基本的にフロントエンド 開発者はローカルで全 API を起動せず、モックサーバー([Prism](https://stoplight.io/open-source/prism/))で開発
2. 新機能を開発して、Dev 環境にデプロイ。
3. ただ、実際に API を呼び出してみるとエラー。
4. 開発者で原因解析
5. 原因は、「モックサーバーの変更が反映できていなかった」
6. API へ要求するリクエストの修正と Prism を動かす swagger.json を修正して、対応完了。

基本的に、モックサーバーは動的な処理が困難なために実際に動かしてみると予期せぬ動きをすることがありました。そのため手動で swagger.json を修正したのもなかなかに苦痛でした。(← これはもしかしたらそういった変換スクリプトを書けば解決できるかもしれません。)
いずれにせよ API に変更がある場合は、モックの修正も必要になるので煩わしさを感じることが多かったです。

### ・マイクロサービスでやるなら API 間のトレーシングやトランザクションの方法は考えておこう

API を跨ぐ数が増える度に、これらのトレーシングやトランザクションの問題は顕在化してきます。
トレーシングについては、ツールとして[Zipkin](https://zipkin.io/)や[Jaeger](https://www.jaegertracing.io/)などのツールが解決策としてあります。ただし、Zipkin や Jaeger などのツールが活躍するのはアプリの監視を始めるフェーズかなと思います。それ以前にログの出力を強化したり、実装上のエラーハンドリングの処理をきちんと実装しておくことが重要だと感じました。マイクロサービスでアプリを構築する場合は、リクエストのステータスをどのように管理していくのかをあらかじめ検証しておく必要があると感じました。
トランザクションについては、複数 API が絡んだ時のデータ不整合を解決するために必要な問題になってきますが、開発開始後にこの問題へ取り組む余裕がほとんどありませんでした。結局オーケストレーションやらコレオグラフィやら SAGA パターンやら TCC パターンなど調査はしたものの、最終的に実装まで移すにはかなりの難易度が高いと感じました。(← 結局実装まではたどり着けませんでした。)

## さいごに：スモールスタートを意識すべきだった

このプロジェクトから学んだ一番の教訓が「**スモールスタート**」です。  
私が開発フェーズで参加した頃からあまりにも開発要件の見積もりが甘いと言わざるを得ませんでしたが、色々新しいアーキテクチャで挑戦する中で開発するプロダクトのレベルを下げて始めないと開発の軌道がどんどん修正しづらくなりました。開発する機能をもっと精査してから開発に着手すべきでした。デザインや仕様の Definition Done の設定が甘かったため、機能の優先度やタスクの振り分けから開発までの流れがチーム全体としても回りづらくなっていました。
他にも、アーキテクチャにこだわりすぎて、開発の本筋とは違う部分で開発者が悩まされることも多かったです。「プロダクトが先かマイクロサービスが先か」という問いがあれば、私は真っ先に「**プロダクトが先**」と回答します。仮にモノリシックなアーキテクチャで開発を進めていたとしても、機能単位やドメイン単位でプログラムが整理されていれば、マイクロサービスとして API を切り出せたように思います。考えてみれば、Google 社も多くのプロダクトをリリースしてメンテナンスしていく中で、認証機能や決済機能などをマイクロサービスとして切り出していくようになったはずです。サービスが何も出来上がっていない状態で「マイクロサービスをやろうか」というのは本末転倒だったのかなと思います。

今回失敗してしまったプロジェクトでは、間違いなく「マイクロサービス」というワードが先行して、未完全な API が複数個できてしまいました。それゆえに１つの API の変更が、サービスメッシュのデメリットが開発段階から負荷になってしまったように思います。マイクロサービスとして独立した汎用性の高いサービスを作るには、それなりの開発レベルを要します。マイクロサービス化自体が、「このモジュールはマイクロサービスとして抽象化ておくと他のプロダクトの開発の時も便利だな」みたいな感じからのスタートで全然いいなと思いました。

---

### 追記

O'Reilly から出版されている「[ユニコーン企業のひみつ](https://www.amazon.co.jp/%E3%83%A6%E3%83%8B%E3%82%B3%E3%83%BC%E3%83%B3%E4%BC%81%E6%A5%AD%E3%81%AE%E3%81%B2%E3%81%BF%E3%81%A4-%E2%80%95Spotify%E3%81%A7%E5%AD%A6%E3%82%93%E3%81%A0%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%A5%E3%81%8F%E3%82%8A%E3%81%A8%E5%83%8D%E3%81%8D%E6%96%B9-Jonathan-Rasmusson/dp/4873119464 'ユニコーン企業のひみつ')」という Spotify での働き方について書かれた本を読んで、今のスタートアップではスクラム開発ですらないらしいということを知りました。スクラムではなくスクワッドというチーム、プロジェクトではなくミッションという単位でソフトウェアの開発やリリースに取り組んでいるようです。本に書かれていることは一例に過ぎないのかもしれませんが、これを読んで日本でも多くの企業がエンジニアの権限や信頼といった部分に投資をして欲しいなと思うばかりです。
